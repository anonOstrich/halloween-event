
generator client {
    provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url = env("POSTGRES_PRISMA_URL") // uses connection pooling
  directUrl = env("POSTGRES_URL_NON_POOLING") // uses a direct connection
}

// Simply for registering user. Not needed after that -> could be more temporary than in the database, too
model PossibleRegistrar {
    hash String @id 
}

model User {
    id Int @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    clerkId String @unique
    email String @unique
    addedMovies Movie[]

    reviews Review[]

    votes Vote[]
}

// TODO: technical specs, availibility on different formats
model Movie {
    id Int @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    title String
    year Int
    description String

    userId Int
    user User @relation(fields: [userId], references: [id])

    movieEvent MovieEvent[]

    reviews Review[]
}

// For now: review connected to movie & user, can pretty easily add different aspects to the review
model Review {
    id Int @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Text might be optional...? 
    reviewText String?

    score Score

    userId Int
    user User @relation(fields: [userId], references: [id])
    

    movieId Int 
    movie Movie @relation(fields: [movieId], references: [id], onDelete: Cascade)

    @@unique([userId, movieId])

}

model MovieEvent {
    id Int @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    movieId Int
    movie Movie @relation(fields: [movieId], references: [id])

    eventId Int
    event Event @relation(fields: [eventId], references: [id])

    votes Vote[]

    @@unique([movieId, eventId])

}


// Should I also store the id of the user creator?
model Event {
    id Int @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    title String
    description String
    theme String
    plannedDate DateTime @db.Date()
    // "pakotus"
    movieClubEvent Boolean @default(false)

    // At first: just one movie
    // Check: one movie can only be added once
    movieEvent MovieEvent[]

}

model Vote {
    id Int @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    userId Int
    user User @relation(fields: [userId], references: [id])

    movieEventId Int
    event MovieEvent @relation(fields: [movieEventId], references: [id])

    voteType VoteType

    @@unique([movieEventId, userId])
}

// Prisma doesn't support checks at the moment, so I'll use enum for int in range 0-19. Could also be done with postgres flavor of SQL, but I prefer to keep the schema in one .prisma file

enum Score {
    ZERO
    ONE
    TWO
    THREE
    FOUR
    FIVE
    SIX
    SEVEN
    EIGHT
    NINE
    TEN
    ELEVEN
    TWELVE
    THIRTEEN
    FOURTEEN
    FIFTEEN
    SIXTEEN
    SEVENTEEN
    EIGHTEEN
    NINETEEN
}

enum VoteType {
    POSITIVE
    NEUTRAL
    NEGATIVE
}